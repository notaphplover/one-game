#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';
import { argv } from 'node:process';

import { Options as $RefOptions } from '@bcherny/json-schema-ref-parser';
import { readApiJsonSchemas } from '@one-game-js/api-json-schemas-provider';
import { Builder, UseCase } from '@one-game-js/backend-common';
import {
  JsonRootSchema202012,
  JsonRootSchema202012Object,
} from '@one-game-js/json-schema-utils';
import { compile } from 'json-schema-to-typescript';
import { Options } from 'prettier';

import { ResolveApiSchemaHttpReferenceQuery } from '../jsonSchema/application/queries/ResolveApiSchemaHttpReferenceQuery';
import { ResolveApiSchemaHttpReferenceUseCase } from '../jsonSchema/application/useCases/ResolveApiSchemaHttpReferenceUseCase';
import { SchemasRefParserOptionsBuilder } from '../jsonSchema/infrastructure/bchernyJsonSchemaRefParser/SchemasRefParserOptionsBuilder';

const ROOT_TYPE_SCHEMA_TS_TYPE_ALIAS: string = 'Types';

const ROOT_TYPE_SCHEMA_ID: string = 'https://onegame.schemas/api/types.json';

const backendPrettierOptions: Options =
  // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
  require('@one-game-js/backend-prettier-config') as Options;

const apiV1TypesJsonSchemasPromise: Promise<JsonRootSchema202012[]> =
  readApiJsonSchemas();

async function getResolveApiSchemaHttpReferenceUseCasePromise(): Promise<
  UseCase<ResolveApiSchemaHttpReferenceQuery, Buffer>
> {
  const apiV1TypesJsonSchemas: JsonRootSchema202012[] =
    await apiV1TypesJsonSchemasPromise;

  const apiV1JsonSchemaIdToBufferMap: Map<string, Buffer> = new Map(
    apiV1TypesJsonSchemas.map(jsonRootSchema202012ToIdToBufferMapEntry),
  );

  const resolveApiSchemaHttpReferenceUseCase: UseCase<
    ResolveApiSchemaHttpReferenceQuery,
    Buffer
  > = new ResolveApiSchemaHttpReferenceUseCase(apiV1JsonSchemaIdToBufferMap);

  return resolveApiSchemaHttpReferenceUseCase;
}

async function getSchemasRefParserOptionsBuilder(): Promise<
  Builder<$RefOptions>
> {
  const resolveApiSchemaHttpReferenceUseCase: UseCase<
    ResolveApiSchemaHttpReferenceQuery,
    Buffer
  > = await getResolveApiSchemaHttpReferenceUseCasePromise();

  const schemasRefParserOptionsBuilder: Builder<$RefOptions> =
    new SchemasRefParserOptionsBuilder(resolveApiSchemaHttpReferenceUseCase);

  return schemasRefParserOptionsBuilder;
}

function jsonRootSchema202012ToIdToBufferMapEntry(
  jsonRootSchema202012: JsonRootSchema202012,
): [string, Buffer] {
  if (typeof jsonRootSchema202012 === 'boolean') {
    throw new Error('Unexpected JSON root schema');
  } else {
    if (jsonRootSchema202012.$id === undefined) {
      throw new Error('Unexpected JSON root object schema without "$id" field');
    } else {
      return [
        jsonRootSchema202012.$id,
        Buffer.from(JSON.stringify(jsonRootSchema202012)),
      ];
    }
  }
}

function arrayHasThreeElements<T>(value: T[]): value is [T, T, T, ...T[]] {
  const fourElementArrayLength: number = 3;

  return value.length >= fourElementArrayLength;
}

async function generateAllSchemas(destinationPath: string): Promise<void> {
  const apiJsonSchemas: JsonRootSchema202012[] =
    await apiV1TypesJsonSchemasPromise;

  const apiV1TypesJsonSchema: JsonRootSchema202012Object | undefined =
    apiJsonSchemas.find(isApiTypesJsonRootSchemaObject);

  if (apiV1TypesJsonSchema === undefined) {
    throw new Error('Api V1 types not found!');
  }

  const tsModel: string = await generateTypescriptModelFromSchema(
    ROOT_TYPE_SCHEMA_TS_TYPE_ALIAS,
    apiV1TypesJsonSchema,
  );

  await fs.mkdir(path.dirname(destinationPath), { recursive: true });

  await fs.writeFile(destinationPath, tsModel);
}

async function generateTypescriptModelFromSchema(
  schemaName: string,
  schema: JsonRootSchema202012Object,
): Promise<string> {
  const schemasRefParserOptionsBuilder: Builder<$RefOptions> =
    await getSchemasRefParserOptionsBuilder();

  const refParserOptions: $RefOptions = schemasRefParserOptionsBuilder.build();

  const tsModel: string = await compile(
    schema as Record<string, unknown>,
    schemaName,
    {
      $refOptions: refParserOptions,
      bannerComment: `/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the generation script to regenerate this file.
 */`,
      cwd: '.',
      declareExternallyReferenced: true,
      ignoreMinAndMaxItems: true,
      strictIndexSignatures: true,
      style: backendPrettierOptions,
      unknownAny: true,
    },
  );

  return tsModel;
}

function isApiTypesJsonRootSchemaObject(
  apiJsonSchema: JsonRootSchema202012,
): apiJsonSchema is JsonRootSchema202012Object {
  return (
    typeof apiJsonSchema === 'object' &&
    apiJsonSchema.$id === ROOT_TYPE_SCHEMA_ID
  );
}

void (async () => {
  if (arrayHasThreeElements(argv)) {
    const destinationFolder: string = argv[2];

    await generateAllSchemas(destinationFolder);
  } else {
    throw new Error('Invalid args!');
  }
})();
