/* eslint-disable */
/**
 * This file was automatically generated by @graphql-codegen/cli.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source graphql file,
 * and run the generation script to regenerate this file.
 */
import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
    };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  Void: { input: any; output: any };
};

export type ActiveGame = {
  __typename?: 'ActiveGame';
  id: Scalars['ID']['output'];
  name: Maybe<Scalars['String']['output']>;
  spec: GameSpec;
  state: ActiveGameState;
};

export type ActiveGameSlot = {
  __typename?: 'ActiveGameSlot';
  cardsAmount: Scalars['Int']['output'];
  userId: Scalars['ID']['output'];
};

export type ActiveGameState = {
  __typename?: 'ActiveGameState';
  currentCard: Card;
  currentColor: CardColor;
  currentDirection: GameDirection;
  currentPlayingSlotIndex: Scalars['Int']['output'];
  currentTurnCardsPlayed: Scalars['Boolean']['output'];
  drawCount: Scalars['Int']['output'];
  slots: Array<Maybe<ActiveGameSlot>>;
  status: ActiveGameStateStatus;
};

export type ActiveGameStateStatus = 'active';

export type Auth = {
  __typename?: 'Auth';
  jwt: Scalars['String']['output'];
};

export type AuthMutation = {
  createAuthByCode: Auth;
  createAuthByCredentials: Auth;
};

export type AuthMutationCreateAuthByCodeArgs = {
  codeAuthCreateInput: CodeAuthCreateInput;
};

export type AuthMutationCreateAuthByCredentialsArgs = {
  emailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
};

export type Card =
  | DrawCard
  | NormalCard
  | ReverseCard
  | SkipCard
  | WildCard
  | WildDraw4Card;

export type CardColor = 'blue' | 'green' | 'red' | 'yellow';

export type CodeAuthCreateInput = {
  code: Scalars['String']['input'];
};

export type DrawCard = {
  __typename?: 'DrawCard';
  color: CardColor;
  kind: DrawCardKind;
};

export type DrawCardKind = 'draw';

export type EmailPasswordAuthCreateInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type FindMyGamesInput = {
  page: InputMaybe<Scalars['Int']['input']>;
  pageSize: InputMaybe<Scalars['Int']['input']>;
  status: InputMaybe<Scalars['String']['input']>;
};

export type FinishedGame = {
  __typename?: 'FinishedGame';
  id: Scalars['ID']['output'];
  name: Maybe<Scalars['String']['output']>;
  spec: GameSpec;
  state: FinishedGameState;
};

export type FinishedGameSlot = {
  __typename?: 'FinishedGameSlot';
  cardsAmount: Scalars['Int']['output'];
  userId: Scalars['String']['output'];
};

export type FinishedGameState = {
  __typename?: 'FinishedGameState';
  slots: Array<Maybe<FinishedGameSlot>>;
  status: FinishedGameStateStatus;
};

export type FinishedGameStateStatus = 'finished';

export type Game = ActiveGame | FinishedGame | NonStartedGame;

export type GameCardSpec = {
  __typename?: 'GameCardSpec';
  amount: Scalars['Int']['output'];
  card: Card;
};

export type GameCreateInput = {
  gameSlotsAmount: Scalars['Int']['input'];
  name: InputMaybe<Scalars['String']['input']>;
  options: GameCreateInputOptions;
};

export type GameCreateInputOptions = {
  chainDraw2Draw2Cards: Scalars['Boolean']['input'];
  chainDraw2Draw4Cards: Scalars['Boolean']['input'];
  chainDraw4Draw2Cards: Scalars['Boolean']['input'];
  chainDraw4Draw4Cards: Scalars['Boolean']['input'];
  playCardIsMandatory: Scalars['Boolean']['input'];
  playMultipleSameCards: Scalars['Boolean']['input'];
  playWildDraw4IfNoOtherAlternative: Scalars['Boolean']['input'];
};

export type GameDirection = 'antiClockwise' | 'clockwise';

export type GameMutation = {
  createGame: NonStartedGame;
  createGameSlot: NonStartedGameSlot;
  passGameTurn: Maybe<Game>;
  playGameCards: Maybe<Game>;
};

export type GameMutationCreateGameArgs = {
  gameCreateInput: GameCreateInput;
};

export type GameMutationCreateGameSlotArgs = {
  gameSlotCreateInput: GameSlotCreateInput;
};

export type GameMutationPassGameTurnArgs = {
  gameId: Scalars['ID']['input'];
  gamePassTurnInput: GamePassTurnInput;
};

export type GameMutationPlayGameCardsArgs = {
  gameId: Scalars['ID']['input'];
  gamePlayCardsInput: GamePlayCardsInput;
};

export type GameOptions = {
  __typename?: 'GameOptions';
  chainDraw2Draw2Cards: Scalars['Boolean']['output'];
  chainDraw2Draw4Cards: Scalars['Boolean']['output'];
  chainDraw4Draw2Cards: Scalars['Boolean']['output'];
  chainDraw4Draw4Cards: Scalars['Boolean']['output'];
  playCardIsMandatory: Scalars['Boolean']['output'];
  playMultipleSameCards: Scalars['Boolean']['output'];
  playWildDraw4IfNoOtherAlternative: Scalars['Boolean']['output'];
};

export type GamePassTurnInput = {
  slotIndex: Scalars['Int']['input'];
};

export type GamePlayCardsInput = {
  cardIndexes: Array<Scalars['Int']['input']>;
  colorChoice: InputMaybe<CardColor>;
  slotIndex: Scalars['Int']['input'];
};

export type GameQuery = {
  gameById: Maybe<Game>;
  myGames: Array<Game>;
};

export type GameQueryGameByIdArgs = {
  id: Scalars['ID']['input'];
};

export type GameQueryMyGamesArgs = {
  findMyGamesInput: InputMaybe<FindMyGamesInput>;
};

export type GameSlotCreateInput = {
  gameId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

export type GameSpec = {
  __typename?: 'GameSpec';
  cardSpecs: Array<GameCardSpec>;
  gameSlotsAmount: Scalars['Int']['output'];
  options: GameOptions;
};

export type NonStartedGame = {
  __typename?: 'NonStartedGame';
  id: Scalars['ID']['output'];
  name: Maybe<Scalars['String']['output']>;
  spec: GameSpec;
  state: NonStartedGameState;
};

export type NonStartedGameSlot = {
  __typename?: 'NonStartedGameSlot';
  userId: Scalars['ID']['output'];
};

export type NonStartedGameState = {
  __typename?: 'NonStartedGameState';
  slots: Array<Maybe<NonStartedGameSlot>>;
  status: NonStartedGameStateStatus;
};

export type NonStartedGameStateStatus = 'nonStarted';

export type NormalCard = {
  __typename?: 'NormalCard';
  color: CardColor;
  kind: NormalCardKind;
  number: Scalars['Int']['output'];
};

export type NormalCardKind = 'normal';

export type ReverseCard = {
  __typename?: 'ReverseCard';
  color: CardColor;
  kind: ReverseCardKind;
};

export type ReverseCardKind = 'reverse';

export type RootMutation = AuthMutation &
  GameMutation &
  UserMutation & {
    __typename?: 'RootMutation';
    createAuthByCode: Auth;
    createAuthByCredentials: Auth;
    createGame: NonStartedGame;
    createGameSlot: NonStartedGameSlot;
    createUser: User;
    deleteUserMe: Maybe<Scalars['Void']['output']>;
    passGameTurn: Maybe<Game>;
    playGameCards: Maybe<Game>;
    updateUserMe: User;
  };

export type RootMutationCreateAuthByCodeArgs = {
  codeAuthCreateInput: CodeAuthCreateInput;
};

export type RootMutationCreateAuthByCredentialsArgs = {
  emailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
};

export type RootMutationCreateGameArgs = {
  gameCreateInput: GameCreateInput;
};

export type RootMutationCreateGameSlotArgs = {
  gameSlotCreateInput: GameSlotCreateInput;
};

export type RootMutationCreateUserArgs = {
  userCreateInput: UserCreateInput;
};

export type RootMutationPassGameTurnArgs = {
  gameId: Scalars['ID']['input'];
  gamePassTurnInput: GamePassTurnInput;
};

export type RootMutationPlayGameCardsArgs = {
  gameId: Scalars['ID']['input'];
  gamePlayCardsInput: GamePlayCardsInput;
};

export type RootMutationUpdateUserMeArgs = {
  userUpdateInput: UserUpdateInput;
};

export type RootQuery = GameQuery &
  UserQuery & {
    __typename?: 'RootQuery';
    gameById: Maybe<Game>;
    myGames: Array<Game>;
    userById: Maybe<User>;
    userMe: User;
  };

export type RootQueryGameByIdArgs = {
  id: Scalars['ID']['input'];
};

export type RootQueryMyGamesArgs = {
  findMyGamesInput: InputMaybe<FindMyGamesInput>;
};

export type RootQueryUserByIdArgs = {
  id: Scalars['ID']['input'];
};

export type SkipCard = {
  __typename?: 'SkipCard';
  color: CardColor;
  kind: SkipCardKind;
};

export type SkipCardKind = 'skip';

export type User = {
  __typename?: 'User';
  active: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type UserCreateInput = {
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type UserMutation = {
  createUser: User;
  deleteUserMe: Maybe<Scalars['Void']['output']>;
  updateUserMe: User;
};

export type UserMutationCreateUserArgs = {
  userCreateInput: UserCreateInput;
};

export type UserMutationUpdateUserMeArgs = {
  userUpdateInput: UserUpdateInput;
};

export type UserQuery = {
  userById: Maybe<User>;
  userMe: User;
};

export type UserQueryUserByIdArgs = {
  id: Scalars['ID']['input'];
};

export type UserUpdateInput = {
  active: InputMaybe<Scalars['Boolean']['input']>;
  name: InputMaybe<Scalars['String']['input']>;
};

export type WildCard = {
  __typename?: 'WildCard';
  kind: WildCardKind;
};

export type WildCardKind = 'wild';

export type WildDraw4Card = {
  __typename?: 'WildDraw4Card';
  kind: WildDraw4CardKind;
};

export type WildDraw4CardKind = 'wildDraw4';

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Partial<T> | Promise<Partial<T>>;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {},
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {},
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<RefType extends Record<string, unknown>> =
  ResolversObject<{
    Card:
      | DrawCard
      | NormalCard
      | ReverseCard
      | SkipCard
      | WildCard
      | WildDraw4Card;
    Game: ActiveGame | FinishedGame | NonStartedGame;
  }>;

/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> =
  ResolversObject<{
    AuthMutation: Omit<RootMutation, 'passGameTurn' | 'playGameCards'> & {
      passGameTurn: Maybe<RefType['Game']>;
      playGameCards: Maybe<RefType['Game']>;
    };
    GameMutation: Omit<RootMutation, 'passGameTurn' | 'playGameCards'> & {
      passGameTurn: Maybe<RefType['Game']>;
      playGameCards: Maybe<RefType['Game']>;
    };
    GameQuery: Omit<RootQuery, 'gameById' | 'myGames'> & {
      gameById: Maybe<RefType['Game']>;
      myGames: Array<RefType['Game']>;
    };
    UserMutation: Omit<RootMutation, 'passGameTurn' | 'playGameCards'> & {
      passGameTurn: Maybe<RefType['Game']>;
      playGameCards: Maybe<RefType['Game']>;
    };
    UserQuery: Omit<RootQuery, 'gameById' | 'myGames'> & {
      gameById: Maybe<RefType['Game']>;
      myGames: Array<RefType['Game']>;
    };
  }>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  ActiveGame: ResolverTypeWrapper<ActiveGame>;
  ActiveGameSlot: ResolverTypeWrapper<ActiveGameSlot>;
  ActiveGameState: ResolverTypeWrapper<
    Omit<ActiveGameState, 'currentCard'> & {
      currentCard: ResolversTypes['Card'];
    }
  >;
  ActiveGameStateStatus: ActiveGameStateStatus;
  Auth: ResolverTypeWrapper<Auth>;
  AuthMutation: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['AuthMutation']
  >;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  Card: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Card']>;
  CardColor: CardColor;
  CodeAuthCreateInput: CodeAuthCreateInput;
  DrawCard: ResolverTypeWrapper<DrawCard>;
  DrawCardKind: DrawCardKind;
  EmailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
  FindMyGamesInput: FindMyGamesInput;
  FinishedGame: ResolverTypeWrapper<FinishedGame>;
  FinishedGameSlot: ResolverTypeWrapper<FinishedGameSlot>;
  FinishedGameState: ResolverTypeWrapper<FinishedGameState>;
  FinishedGameStateStatus: FinishedGameStateStatus;
  Game: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['Game']>;
  GameCardSpec: ResolverTypeWrapper<
    Omit<GameCardSpec, 'card'> & { card: ResolversTypes['Card'] }
  >;
  GameCreateInput: GameCreateInput;
  GameCreateInputOptions: GameCreateInputOptions;
  GameDirection: GameDirection;
  GameMutation: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['GameMutation']
  >;
  GameOptions: ResolverTypeWrapper<GameOptions>;
  GamePassTurnInput: GamePassTurnInput;
  GamePlayCardsInput: GamePlayCardsInput;
  GameQuery: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['GameQuery']
  >;
  GameSlotCreateInput: GameSlotCreateInput;
  GameSpec: ResolverTypeWrapper<GameSpec>;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  NonStartedGame: ResolverTypeWrapper<NonStartedGame>;
  NonStartedGameSlot: ResolverTypeWrapper<NonStartedGameSlot>;
  NonStartedGameState: ResolverTypeWrapper<NonStartedGameState>;
  NonStartedGameStateStatus: NonStartedGameStateStatus;
  NormalCard: ResolverTypeWrapper<NormalCard>;
  NormalCardKind: NormalCardKind;
  ReverseCard: ResolverTypeWrapper<ReverseCard>;
  ReverseCardKind: ReverseCardKind;
  RootMutation: ResolverTypeWrapper<{}>;
  RootQuery: ResolverTypeWrapper<{}>;
  SkipCard: ResolverTypeWrapper<SkipCard>;
  SkipCardKind: SkipCardKind;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  User: ResolverTypeWrapper<User>;
  UserCreateInput: UserCreateInput;
  UserMutation: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['UserMutation']
  >;
  UserQuery: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['UserQuery']
  >;
  UserUpdateInput: UserUpdateInput;
  Void: ResolverTypeWrapper<Scalars['Void']['output']>;
  WildCard: ResolverTypeWrapper<WildCard>;
  WildCardKind: WildCardKind;
  WildDraw4Card: ResolverTypeWrapper<WildDraw4Card>;
  WildDraw4CardKind: WildDraw4CardKind;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  ActiveGame: ActiveGame;
  ActiveGameSlot: ActiveGameSlot;
  ActiveGameState: Omit<ActiveGameState, 'currentCard'> & {
    currentCard: ResolversParentTypes['Card'];
  };
  Auth: Auth;
  AuthMutation: ResolversInterfaceTypes<ResolversParentTypes>['AuthMutation'];
  Boolean: Scalars['Boolean']['output'];
  Card: ResolversUnionTypes<ResolversParentTypes>['Card'];
  CodeAuthCreateInput: CodeAuthCreateInput;
  DrawCard: DrawCard;
  EmailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
  FindMyGamesInput: FindMyGamesInput;
  FinishedGame: FinishedGame;
  FinishedGameSlot: FinishedGameSlot;
  FinishedGameState: FinishedGameState;
  Game: ResolversUnionTypes<ResolversParentTypes>['Game'];
  GameCardSpec: Omit<GameCardSpec, 'card'> & {
    card: ResolversParentTypes['Card'];
  };
  GameCreateInput: GameCreateInput;
  GameCreateInputOptions: GameCreateInputOptions;
  GameMutation: ResolversInterfaceTypes<ResolversParentTypes>['GameMutation'];
  GameOptions: GameOptions;
  GamePassTurnInput: GamePassTurnInput;
  GamePlayCardsInput: GamePlayCardsInput;
  GameQuery: ResolversInterfaceTypes<ResolversParentTypes>['GameQuery'];
  GameSlotCreateInput: GameSlotCreateInput;
  GameSpec: GameSpec;
  ID: Scalars['ID']['output'];
  Int: Scalars['Int']['output'];
  NonStartedGame: NonStartedGame;
  NonStartedGameSlot: NonStartedGameSlot;
  NonStartedGameState: NonStartedGameState;
  NormalCard: NormalCard;
  ReverseCard: ReverseCard;
  RootMutation: {};
  RootQuery: {};
  SkipCard: SkipCard;
  String: Scalars['String']['output'];
  User: User;
  UserCreateInput: UserCreateInput;
  UserMutation: ResolversInterfaceTypes<ResolversParentTypes>['UserMutation'];
  UserQuery: ResolversInterfaceTypes<ResolversParentTypes>['UserQuery'];
  UserUpdateInput: UserUpdateInput;
  Void: Scalars['Void']['output'];
  WildCard: WildCard;
  WildDraw4Card: WildDraw4Card;
}>;

export type ActiveGameResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['ActiveGame'] = ResolversParentTypes['ActiveGame'],
> = ResolversObject<{
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec: Resolver<ResolversTypes['GameSpec'], ParentType, ContextType>;
  state: Resolver<ResolversTypes['ActiveGameState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ActiveGameSlotResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['ActiveGameSlot'] = ResolversParentTypes['ActiveGameSlot'],
> = ResolversObject<{
  cardsAmount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userId: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ActiveGameStateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['ActiveGameState'] = ResolversParentTypes['ActiveGameState'],
> = ResolversObject<{
  currentCard: Resolver<ResolversTypes['Card'], ParentType, ContextType>;
  currentColor: Resolver<ResolversTypes['CardColor'], ParentType, ContextType>;
  currentDirection: Resolver<
    ResolversTypes['GameDirection'],
    ParentType,
    ContextType
  >;
  currentPlayingSlotIndex: Resolver<
    ResolversTypes['Int'],
    ParentType,
    ContextType
  >;
  currentTurnCardsPlayed: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  drawCount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  slots: Resolver<
    Array<Maybe<ResolversTypes['ActiveGameSlot']>>,
    ParentType,
    ContextType
  >;
  status: Resolver<
    ResolversTypes['ActiveGameStateStatus'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['Auth'] = ResolversParentTypes['Auth'],
> = ResolversObject<{
  jwt: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['AuthMutation'] = ResolversParentTypes['AuthMutation'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootMutation', ParentType, ContextType>;
  createAuthByCode: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<AuthMutationCreateAuthByCodeArgs, 'codeAuthCreateInput'>
  >;
  createAuthByCredentials: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<
      AuthMutationCreateAuthByCredentialsArgs,
      'emailPasswordAuthCreateInput'
    >
  >;
}>;

export type CardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['Card'] = ResolversParentTypes['Card'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    | 'DrawCard'
    | 'NormalCard'
    | 'ReverseCard'
    | 'SkipCard'
    | 'WildCard'
    | 'WildDraw4Card',
    ParentType,
    ContextType
  >;
}>;

export type DrawCardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['DrawCard'] = ResolversParentTypes['DrawCard'],
> = ResolversObject<{
  color: Resolver<ResolversTypes['CardColor'], ParentType, ContextType>;
  kind: Resolver<ResolversTypes['DrawCardKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FinishedGameResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['FinishedGame'] = ResolversParentTypes['FinishedGame'],
> = ResolversObject<{
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec: Resolver<ResolversTypes['GameSpec'], ParentType, ContextType>;
  state: Resolver<ResolversTypes['FinishedGameState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FinishedGameSlotResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['FinishedGameSlot'] = ResolversParentTypes['FinishedGameSlot'],
> = ResolversObject<{
  cardsAmount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userId: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type FinishedGameStateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['FinishedGameState'] = ResolversParentTypes['FinishedGameState'],
> = ResolversObject<{
  slots: Resolver<
    Array<Maybe<ResolversTypes['FinishedGameSlot']>>,
    ParentType,
    ContextType
  >;
  status: Resolver<
    ResolversTypes['FinishedGameStateStatus'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['Game'] = ResolversParentTypes['Game'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<
    'ActiveGame' | 'FinishedGame' | 'NonStartedGame',
    ParentType,
    ContextType
  >;
}>;

export type GameCardSpecResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['GameCardSpec'] = ResolversParentTypes['GameCardSpec'],
> = ResolversObject<{
  amount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  card: Resolver<ResolversTypes['Card'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['GameMutation'] = ResolversParentTypes['GameMutation'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootMutation', ParentType, ContextType>;
  createGame: Resolver<
    ResolversTypes['NonStartedGame'],
    ParentType,
    ContextType,
    RequireFields<GameMutationCreateGameArgs, 'gameCreateInput'>
  >;
  createGameSlot: Resolver<
    ResolversTypes['NonStartedGameSlot'],
    ParentType,
    ContextType,
    RequireFields<GameMutationCreateGameSlotArgs, 'gameSlotCreateInput'>
  >;
  passGameTurn: Resolver<
    Maybe<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    RequireFields<GameMutationPassGameTurnArgs, 'gameId' | 'gamePassTurnInput'>
  >;
  playGameCards: Resolver<
    Maybe<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    RequireFields<
      GameMutationPlayGameCardsArgs,
      'gameId' | 'gamePlayCardsInput'
    >
  >;
}>;

export type GameOptionsResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['GameOptions'] = ResolversParentTypes['GameOptions'],
> = ResolversObject<{
  chainDraw2Draw2Cards: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  chainDraw2Draw4Cards: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  chainDraw4Draw2Cards: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  chainDraw4Draw4Cards: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  playCardIsMandatory: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  playMultipleSameCards: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  playWildDraw4IfNoOtherAlternative: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type GameQueryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['GameQuery'] = ResolversParentTypes['GameQuery'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootQuery', ParentType, ContextType>;
  gameById: Resolver<
    Maybe<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    RequireFields<GameQueryGameByIdArgs, 'id'>
  >;
  myGames: Resolver<
    Array<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    Partial<GameQueryMyGamesArgs>
  >;
}>;

export type GameSpecResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['GameSpec'] = ResolversParentTypes['GameSpec'],
> = ResolversObject<{
  cardSpecs: Resolver<
    Array<ResolversTypes['GameCardSpec']>,
    ParentType,
    ContextType
  >;
  gameSlotsAmount: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  options: Resolver<ResolversTypes['GameOptions'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NonStartedGameResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['NonStartedGame'] = ResolversParentTypes['NonStartedGame'],
> = ResolversObject<{
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  spec: Resolver<ResolversTypes['GameSpec'], ParentType, ContextType>;
  state: Resolver<
    ResolversTypes['NonStartedGameState'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NonStartedGameSlotResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['NonStartedGameSlot'] = ResolversParentTypes['NonStartedGameSlot'],
> = ResolversObject<{
  userId: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NonStartedGameStateResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['NonStartedGameState'] = ResolversParentTypes['NonStartedGameState'],
> = ResolversObject<{
  slots: Resolver<
    Array<Maybe<ResolversTypes['NonStartedGameSlot']>>,
    ParentType,
    ContextType
  >;
  status: Resolver<
    ResolversTypes['NonStartedGameStateStatus'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type NormalCardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['NormalCard'] = ResolversParentTypes['NormalCard'],
> = ResolversObject<{
  color: Resolver<ResolversTypes['CardColor'], ParentType, ContextType>;
  kind: Resolver<ResolversTypes['NormalCardKind'], ParentType, ContextType>;
  number: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type ReverseCardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['ReverseCard'] = ResolversParentTypes['ReverseCard'],
> = ResolversObject<{
  color: Resolver<ResolversTypes['CardColor'], ParentType, ContextType>;
  kind: Resolver<ResolversTypes['ReverseCardKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type RootMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['RootMutation'] = ResolversParentTypes['RootMutation'],
> = ResolversObject<{
  createAuthByCode: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<RootMutationCreateAuthByCodeArgs, 'codeAuthCreateInput'>
  >;
  createAuthByCredentials: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<
      RootMutationCreateAuthByCredentialsArgs,
      'emailPasswordAuthCreateInput'
    >
  >;
  createGame: Resolver<
    ResolversTypes['NonStartedGame'],
    ParentType,
    ContextType,
    RequireFields<RootMutationCreateGameArgs, 'gameCreateInput'>
  >;
  createGameSlot: Resolver<
    ResolversTypes['NonStartedGameSlot'],
    ParentType,
    ContextType,
    RequireFields<RootMutationCreateGameSlotArgs, 'gameSlotCreateInput'>
  >;
  createUser: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<RootMutationCreateUserArgs, 'userCreateInput'>
  >;
  deleteUserMe: Resolver<
    Maybe<ResolversTypes['Void']>,
    ParentType,
    ContextType
  >;
  passGameTurn: Resolver<
    Maybe<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    RequireFields<RootMutationPassGameTurnArgs, 'gameId' | 'gamePassTurnInput'>
  >;
  playGameCards: Resolver<
    Maybe<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    RequireFields<
      RootMutationPlayGameCardsArgs,
      'gameId' | 'gamePlayCardsInput'
    >
  >;
  updateUserMe: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<RootMutationUpdateUserMeArgs, 'userUpdateInput'>
  >;
}>;

export type RootQueryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['RootQuery'] = ResolversParentTypes['RootQuery'],
> = ResolversObject<{
  gameById: Resolver<
    Maybe<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    RequireFields<RootQueryGameByIdArgs, 'id'>
  >;
  myGames: Resolver<
    Array<ResolversTypes['Game']>,
    ParentType,
    ContextType,
    Partial<RootQueryMyGamesArgs>
  >;
  userById: Resolver<
    Maybe<ResolversTypes['User']>,
    ParentType,
    ContextType,
    RequireFields<RootQueryUserByIdArgs, 'id'>
  >;
  userMe: Resolver<ResolversTypes['User'], ParentType, ContextType>;
}>;

export type SkipCardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['SkipCard'] = ResolversParentTypes['SkipCard'],
> = ResolversObject<{
  color: Resolver<ResolversTypes['CardColor'], ParentType, ContextType>;
  kind: Resolver<ResolversTypes['SkipCardKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['User'] = ResolversParentTypes['User'],
> = ResolversObject<{
  active: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['UserMutation'] = ResolversParentTypes['UserMutation'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootMutation', ParentType, ContextType>;
  createUser: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<UserMutationCreateUserArgs, 'userCreateInput'>
  >;
  deleteUserMe: Resolver<
    Maybe<ResolversTypes['Void']>,
    ParentType,
    ContextType
  >;
  updateUserMe: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<UserMutationUpdateUserMeArgs, 'userUpdateInput'>
  >;
}>;

export type UserQueryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['UserQuery'] = ResolversParentTypes['UserQuery'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootQuery', ParentType, ContextType>;
  userById: Resolver<
    Maybe<ResolversTypes['User']>,
    ParentType,
    ContextType,
    RequireFields<UserQueryUserByIdArgs, 'id'>
  >;
  userMe: Resolver<ResolversTypes['User'], ParentType, ContextType>;
}>;

export interface VoidScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['Void'], any> {
  name: 'Void';
}

export type WildCardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['WildCard'] = ResolversParentTypes['WildCard'],
> = ResolversObject<{
  kind: Resolver<ResolversTypes['WildCardKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type WildDraw4CardResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['WildDraw4Card'] = ResolversParentTypes['WildDraw4Card'],
> = ResolversObject<{
  kind: Resolver<ResolversTypes['WildDraw4CardKind'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  ActiveGame: ActiveGameResolvers<ContextType>;
  ActiveGameSlot: ActiveGameSlotResolvers<ContextType>;
  ActiveGameState: ActiveGameStateResolvers<ContextType>;
  Auth: AuthResolvers<ContextType>;
  AuthMutation: AuthMutationResolvers<ContextType>;
  Card: CardResolvers<ContextType>;
  DrawCard: DrawCardResolvers<ContextType>;
  FinishedGame: FinishedGameResolvers<ContextType>;
  FinishedGameSlot: FinishedGameSlotResolvers<ContextType>;
  FinishedGameState: FinishedGameStateResolvers<ContextType>;
  Game: GameResolvers<ContextType>;
  GameCardSpec: GameCardSpecResolvers<ContextType>;
  GameMutation: GameMutationResolvers<ContextType>;
  GameOptions: GameOptionsResolvers<ContextType>;
  GameQuery: GameQueryResolvers<ContextType>;
  GameSpec: GameSpecResolvers<ContextType>;
  NonStartedGame: NonStartedGameResolvers<ContextType>;
  NonStartedGameSlot: NonStartedGameSlotResolvers<ContextType>;
  NonStartedGameState: NonStartedGameStateResolvers<ContextType>;
  NormalCard: NormalCardResolvers<ContextType>;
  ReverseCard: ReverseCardResolvers<ContextType>;
  RootMutation: RootMutationResolvers<ContextType>;
  RootQuery: RootQueryResolvers<ContextType>;
  SkipCard: SkipCardResolvers<ContextType>;
  User: UserResolvers<ContextType>;
  UserMutation: UserMutationResolvers<ContextType>;
  UserQuery: UserQueryResolvers<ContextType>;
  Void: GraphQLScalarType;
  WildCard: WildCardResolvers<ContextType>;
  WildDraw4Card: WildDraw4CardResolvers<ContextType>;
}>;
