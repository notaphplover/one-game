/* eslint-disable */
/**
 * This file was automatically generated by @graphql-codegen/cli.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source graphql file,
 * and run the generation script to regenerate this file.
 */
import { GraphQLResolveInfo } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
    };
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
};

export type Auth = {
  __typename?: 'Auth';
  jwt: Scalars['String']['output'];
};

export type AuthMutation = {
  createAuthByCode: Auth;
  createAuthByCredentials: Auth;
};

export type AuthMutationCreateAuthByCodeArgs = {
  codeAuthCreateInput: CodeAuthCreateInput;
};

export type AuthMutationCreateAuthByCredentialsArgs = {
  emailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
};

export type CodeAuthCreateInput = {
  code: Scalars['String']['input'];
};

export type EmailPasswordAuthCreateInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type RootMutation = AuthMutation &
  UserMutation & {
    __typename?: 'RootMutation';
    createAuthByCode: Auth;
    createAuthByCredentials: Auth;
    createUser: User;
    updateUserMe: User;
  };

export type RootMutationCreateAuthByCodeArgs = {
  codeAuthCreateInput: CodeAuthCreateInput;
};

export type RootMutationCreateAuthByCredentialsArgs = {
  emailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
};

export type RootMutationCreateUserArgs = {
  userCreateInput: UserCreateInput;
};

export type RootMutationUpdateUserMeArgs = {
  userUpdateInput: UserUpdateInput;
};

export type RootQuery = UserQuery & {
  __typename?: 'RootQuery';
  userById: Maybe<User>;
};

export type RootQueryUserByIdArgs = {
  id: Scalars['ID']['input'];
};

export type User = {
  __typename?: 'User';
  active: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type UserCreateInput = {
  email: Scalars['String']['input'];
  name: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type UserMutation = {
  createUser: User;
  updateUserMe: User;
};

export type UserMutationCreateUserArgs = {
  userCreateInput: UserCreateInput;
};

export type UserMutationUpdateUserMeArgs = {
  userUpdateInput: UserUpdateInput;
};

export type UserQuery = {
  userById: Maybe<User>;
};

export type UserQueryUserByIdArgs = {
  id: Scalars['ID']['input'];
};

export type UserUpdateInput = {
  active: InputMaybe<Scalars['Boolean']['input']>;
  name: InputMaybe<Scalars['String']['input']>;
};

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs,
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {},
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo,
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo,
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {},
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo,
) => TResult | Promise<TResult>;

/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> =
  ResolversObject<{
    AuthMutation: RootMutation;
    UserMutation: RootMutation;
    UserQuery: RootQuery;
  }>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Auth: ResolverTypeWrapper<Auth>;
  AuthMutation: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['AuthMutation']
  >;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  CodeAuthCreateInput: CodeAuthCreateInput;
  EmailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  RootMutation: ResolverTypeWrapper<{}>;
  RootQuery: ResolverTypeWrapper<{}>;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  User: ResolverTypeWrapper<User>;
  UserCreateInput: UserCreateInput;
  UserMutation: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['UserMutation']
  >;
  UserQuery: ResolverTypeWrapper<
    ResolversInterfaceTypes<ResolversTypes>['UserQuery']
  >;
  UserUpdateInput: UserUpdateInput;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Auth: Auth;
  AuthMutation: ResolversInterfaceTypes<ResolversParentTypes>['AuthMutation'];
  Boolean: Scalars['Boolean']['output'];
  CodeAuthCreateInput: CodeAuthCreateInput;
  EmailPasswordAuthCreateInput: EmailPasswordAuthCreateInput;
  ID: Scalars['ID']['output'];
  RootMutation: {};
  RootQuery: {};
  String: Scalars['String']['output'];
  User: User;
  UserCreateInput: UserCreateInput;
  UserMutation: ResolversInterfaceTypes<ResolversParentTypes>['UserMutation'];
  UserQuery: ResolversInterfaceTypes<ResolversParentTypes>['UserQuery'];
  UserUpdateInput: UserUpdateInput;
}>;

export type AuthResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['Auth'] = ResolversParentTypes['Auth'],
> = ResolversObject<{
  jwt: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type AuthMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['AuthMutation'] = ResolversParentTypes['AuthMutation'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootMutation', ParentType, ContextType>;
  createAuthByCode: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<AuthMutationCreateAuthByCodeArgs, 'codeAuthCreateInput'>
  >;
  createAuthByCredentials: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<
      AuthMutationCreateAuthByCredentialsArgs,
      'emailPasswordAuthCreateInput'
    >
  >;
}>;

export type RootMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['RootMutation'] = ResolversParentTypes['RootMutation'],
> = ResolversObject<{
  createAuthByCode: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<RootMutationCreateAuthByCodeArgs, 'codeAuthCreateInput'>
  >;
  createAuthByCredentials: Resolver<
    ResolversTypes['Auth'],
    ParentType,
    ContextType,
    RequireFields<
      RootMutationCreateAuthByCredentialsArgs,
      'emailPasswordAuthCreateInput'
    >
  >;
  createUser: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<RootMutationCreateUserArgs, 'userCreateInput'>
  >;
  updateUserMe: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<RootMutationUpdateUserMeArgs, 'userUpdateInput'>
  >;
}>;

export type RootQueryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['RootQuery'] = ResolversParentTypes['RootQuery'],
> = ResolversObject<{
  userById: Resolver<
    Maybe<ResolversTypes['User']>,
    ParentType,
    ContextType,
    RequireFields<RootQueryUserByIdArgs, 'id'>
  >;
}>;

export type UserResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['User'] = ResolversParentTypes['User'],
> = ResolversObject<{
  active: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type UserMutationResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['UserMutation'] = ResolversParentTypes['UserMutation'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootMutation', ParentType, ContextType>;
  createUser: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<UserMutationCreateUserArgs, 'userCreateInput'>
  >;
  updateUserMe: Resolver<
    ResolversTypes['User'],
    ParentType,
    ContextType,
    RequireFields<UserMutationUpdateUserMeArgs, 'userUpdateInput'>
  >;
}>;

export type UserQueryResolvers<
  ContextType = any,
  ParentType extends
    ResolversParentTypes['UserQuery'] = ResolversParentTypes['UserQuery'],
> = ResolversObject<{
  __resolveType: TypeResolveFn<'RootQuery', ParentType, ContextType>;
  userById: Resolver<
    Maybe<ResolversTypes['User']>,
    ParentType,
    ContextType,
    RequireFields<UserQueryUserByIdArgs, 'id'>
  >;
}>;

export type Resolvers<ContextType = any> = ResolversObject<{
  Auth: AuthResolvers<ContextType>;
  AuthMutation: AuthMutationResolvers<ContextType>;
  RootMutation: RootMutationResolvers<ContextType>;
  RootQuery: RootQueryResolvers<ContextType>;
  User: UserResolvers<ContextType>;
  UserMutation: UserMutationResolvers<ContextType>;
  UserQuery: UserQueryResolvers<ContextType>;
}>;
